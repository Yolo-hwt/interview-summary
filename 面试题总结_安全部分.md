# XSS 跨站脚本攻击

## **什么是xss**

**Cross-Site Scripting（跨站脚本攻击）**简称 XSS，是一种**代码注入攻击**。

攻击者通过在目标网站上**注入恶意脚本**，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可**获取用户的敏感信息**如 Cookie、SessionID 等，进而危害数据安全。

**！！！简单来说,任何可以输入的地方都有可能引起,包括URL!**

## **XSS 常见的注入方法**

- 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。
- 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。
- 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。
- 在标签的 href、src 等属性中，包含 `javascript:` (伪协议)等可执行代码。
- 在 onload、onerror、onclick 等事件中，注入不受控制代码。
- 在 style 属性和标签中，包含类似 `background-image:url("javascript:...");` 的代码（新版本浏览器已经可以防范）。
- 在 style 属性和标签中，包含类似 `expression(...)` 的 CSS 表达式代码（新版本浏览器已经可以防范）。

## XSS 攻击的分类

根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。

- **存储型**

一种持久性的xss攻击，因为攻击者将代码注入了服务器端数据库

存储型 XSS 的攻击步骤：

1. 攻击者将**恶意代码提交到目标网站的数据库**中。
2. 用户打开目标网站时，网站**服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器**。
3. 用户**浏览器接收到响应后解析执行**，混在其中的恶意代码也被执行。
4. 恶意代码**窃取用户数据并发送到攻击者的网站**，或者**冒充用户的行为，调用目标网站接口**执行攻击者指定的操作。

！！！最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有**更高的隐蔽性**，所以危害更大，因为**它不需要用户手动触发**。**任何允许用户存储数据的web程序都可能存在存储型XSS漏洞**，当攻击者提交一段XSS代码后，被服务器端接收并存储，当**所有浏览者访问某个页面时都会被XSS**。



- **反射型**

非持久性xss，对url操作注入恶意代码，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

反射型 XSS 的攻击步骤：

1. 攻击者**构造出特殊的 URL，其中包含恶意代码。**
2. 用户打开带有恶意代码的 URL 时，网站**服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器**。
3. 用户**浏览器接收到响应后解析执行**，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

**反射型 XSS 跟存储型 XSS 的区别**

存储型 XSS 的恶意代码存在**数据库**里，反射型 XSS 的恶意代码存在 **URL** 里。



- **DOM型**

常出现在onload事件和href事件中的javascript

DOM 型 XSS 的攻击步骤：

1. 攻击者**构造出特殊的 URL**，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，**前端 JavaScript 取出 URL 中的恶意代码并执行。**
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

**DOM 型 XSS 跟前两种 XSS 的区别**

DOM 型 XSS 攻击中，取出和执行恶意代码**由浏览器端完成**，属于前端 JavaScript 自身的安全漏洞，而**其他两种 XSS 都属于服务端的安全漏洞**。


**对比:**

| 类型       | 存储区                  | 插入点          |
| ---------- | ----------------------- | --------------- |
| 存储型 XSS | 后端数据库              | HTML            |
| 反射型 XSS | URL                     | HTML            |
| DOM 型 XSS | 后端数据库/前端存储/URL | 前端 JavaScript |



## 防范XSS

**常用方法**

- **httpOnly:** 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。

- **输入过滤:** 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是前端负责，后端也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。

- **转义 HTML:** 如果拼接 HTML 是必要的，就需要对于引号，尖括号，斜杠进行转义,但这还不是很完善.想对 HTML 模板各处插入点进行充分的转义,就需要采用合适的转义库.(可以看下这个[库](https://link.juejin.cn?target=https%3A%2F%2Fjsxss.com%2Fzh%2Findex.html),还是中文的)

- **白名单:** 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。

**预防存储型和反射型**

1.改成纯前端渲染，把代码和数据分隔开。

2.对 HTML 做充分转义。

**解释：**

纯前端渲染的过程

1. 浏览器先加载一个静态 HTML，此 HTML 中**不包含任何跟业务相关的数据。**
2. 然后浏览器执行 HTML 中的 JavaScript。
3. JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。



在很多内部、管理系统中，采用纯前端渲染是非常合适的。

但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题,这时就需要对HTML进行充分的转义。



**预防dom型xss**

DOM 型 XSS 攻击，实际上就是网站前端 JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等。

DOM 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，JavaScript 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。

# CSRF 跨站点请求伪造

## 什么是 CSRF

**跨站请求伪造（英语：Cross-site request forgery）**，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF，

是一种**挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法**。

如:攻击者**诱导受害者进入第三方网站**，在第三方网站中，向被攻击网站发送跨站请求。

**利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。**

![简而言之：网站过分相信用户](面试题总结_安全部分.assets/738264eeda674696989fc7b71c80c152tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp)


要完成一次CSRF攻击，受害者必须依次完成两个步骤：

1.**登录受信任网站A**，并在本地生成Cookie

2.在**不登出A的情况下，访问危险网站B。**

## 常见的CSRF攻击类型

- **GET类型的CSRF**

GET类型的CSRF利用非常简单，只需要**一个HTTP请求**，一般会这样利用：

```html
 <img src="http://bank.example/withdraw?amount=10000&for=hacker" > 
```

在受害者访问含有这个img的页面后，浏览器会自动向`http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker`发出一次HTTP请求。bank.example就会收到**包含受害者登录信息的一次跨域请求**。

- **POST类型的CSRF**

这种类型的CSRF利用起来通常使用的是**一个自动提交的表单**，如：

```html
 <form action="http://bank.example/withdraw" method=POST>
    <input type="hidden" name="account" value="xiaoming" />
    <input type="hidden" name="amount" value="10000" />
    <input type="hidden" name="for" value="hacker" />
</form>
<script> document.forms[0].submit(); </script> //自动提交
```

访问该页面后，表单会自动提交，相当于**模拟用户完成了一次POST操作**。

POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。

任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，**后端接口不能将安全寄托在仅允许POST上面**。

- **链接类型的CSRF**

链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式**诱导用户中招**，攻击者通常会以比较夸张的词语诱骗用户点击，例如：

```html
  <a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">
  重磅消息！！
  <a/>
```

## CSRF的特点

- 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
- 攻击**利用受害者在被攻击网站的登录凭证，冒充受害者提交操作**；而不是直接窃取数据。
- 整个过程攻击者并**不能获取到受害者的登录凭证**，仅仅是“冒用”。
- 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如**可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。**



**CSRF与 XSS 区别**

- **通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。**
- 本质上讲，XSS 是代码注入问题，**CSRF 是 HTTP 问题。** XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。**CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。**

## 防范CSRF

- 验证码；强制用户**必须与应用进行交互才能完成最终请求**。此种方式能很好的遏制 csrf，但是用户体验比较差。
- Referer check；**请求来源限制**，此种方法成本最低，但是并不能保证 100% 有效，因为**服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险**。
- token；**token 验证的 CSRF 防御机制是公认最合适的方案，若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。**

​		CSRF 攻击只是借用了 Cookie伪造请求，**并不能获取 Cookie 中的信息**，**所以不能获取 Cookie 中的 token**，把请求发送到服务器端时，token 验证不通过，也就不会处理请求了



**注意点**

**cookie不是同源才共享的吗？为什么还会有CSRF呢？**

cookie是同源才共享，csrf是跨站请求，由不同源的网站发起的，**cookie不设置samesite不会关注发起的网站，只会关注请求的网站**